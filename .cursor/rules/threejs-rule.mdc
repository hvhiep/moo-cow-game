---
description: Threejs best practices
globs:
alwaysApply: false
---

There are some tips and best practices of threejs, React Three Fiber that you should follow:

# For threejs

## General Tips

Object creation in JavaScript is expensive, so don’t create objects in a loop. Instead, create a single object such as a Vector3 and use vector.set() or similar methods to reuse a that inside the loop.
The same goes for your render loop. To make sure your app runs at a buttery smooth sixty frames per second, do as little work as possible in your render loop. Don’t create new objects every frame.
Always use BufferGeometry instead of Geometry, it’s faster.
The same goes for the pre-built objects, always use the buffer geometry version ( BoxBufferGeometry rather than BoxGeometry).
Always try to reuse objects such as objects, materials, textures etc. (although updating some things may be slower than creating new ones, see texture tips below).

## SI Units

Distance is measured in meters (1 three.js unit = 1 meter).
Time is measured in seconds.
Light is measured in SI light units, Candela (cd), Lumen (lm), and Lux (lx) (as long as you turn on renderer.physicallyCorrectLights, at least).

## Accurate Colors

For (nearly) accurate colors, use these settings for the renderer:

```js
renderer.gammaFactor = 2.2;
renderer.outputEncoding = THREE.sRGBEncoding;
```

For colors do this:

```js
const color = new Color(0x800080);
color.convertSRGBToLinear();
```

Or, in the more common case of using a color in a material:

```js
const material = new MeshBasicMaterial({ color: 0x800080 });
material.color.convertSRGBToLinear();
```

Finally, to get (nearly) correct colors in your textures, you need to set the texture encoding for the color, environment, and emissive maps only:

```js
import { sRGBEncoding } from "./vendor/three/build/three.module.js";

const colorMap = new TextureLoader().load("colorMap.jpg");
colorMap.encoding = sRGBEncoding;
```

All other texture types should remain in linear color space. This is the default, so you don’t need to change the encoding for any textures other than color, environment, and emissive maps.

Note that I’m saying nearly correct here since three.js color management is not quite correct at the moment. Hopefully, it will be fixed soon, but in the meantime, any inaccuracy in color will be so minor that it’s very unlikely anybody will notice unless you are doing scientific or medical renderings.

## JavaScript

Don’t assume you know what will be faster
The JavaScript engines used by web browsers change frequently and do an amazing amount of optimization of your code behind the scenes. Don’t trust your intuition about what will be faster, always test. Don’t listen to articles from a few years ago telling you to avoid certain methods such as array.map or array.forEach. Test these for yourself, or find articles from the last few months with proper tests.

Use a style guide and linter
Personally, I use a combination of Eslint, Prettier, and the Airbnb style guide. This took me around 30 minutes to set up in VSCode using this tutorial ( part 2), and now I never have to waste my time with formatting, linting, or wondering whether a particular piece of syntax is a good idea, ever again.

## Models, Meshes and Other Visible Thing

Avoid using common text-based 3D data formats, such as Wavefront OBJ or COLLADA, for asset delivery. Instead, use formats optimized for the web, such as glTF.
Use Draco mesh compression with glTF. Sometimes this reduces glTF files to less than 10% of their original size!
Alternatively, there is a new kid on the block called gltfpack which in some cases may give even better results than Draco.
If you need to make large groups of objects visible and invisible (or add/remove them from your scene), consider using Layers for best performance.
Objects at the same exact same position cause flickering (Z-fighting). Try offsetting things by a tiny amount like 0.001 to make things look like they are in the same position while keeping your GPU happy.
Keep your scene centered around the origin to reduce floating-point errors at large coordinates.
Never move your Scene. It gets created at (0,0,0), and this is the default frame of reference for all the objects inside it.

## Camera

Make your frustum as small as possible for better performance. It’s fine to use a large frustum in development, but once you are fine-tuning your app for deployment, make your frustum as small as possible to gain a few vital FPS.
Don’t put things right on the far clipping plane (especially if your far clipping plane is really big), as this can cause flickering.

## Renderer

Don’t enable preserveDrawingBuffer unless you need it.
Disable the alpha buffer unless you need it.
Don’t enable the stencil buffer unless you need it.
Disable the depth buffer unless you need it (but you probably do need it).
Use powerPreference: "high-performance" when creating the renderer. This may encourage a user’s system to choose the high-performance GPU, in multi-GPU systems.
Consider only rendering when the camera position changes by epsilon or when an animation happens.
If your scene is static and uses OrbitControls, you can listen for the control’s change event. This way you can render the scene only when the camera moves:

```js
OrbitControls.addEventListener("change", () => renderer.render(scene, camera));
```

You won’t get a higher frame rate from the last two, but what you will get is less fans switching on, and less battery drain on mobile devices.

Note: I’ve seen a few places around the web recommending that you disable anti-aliasing and apply a post-processing AA pass instead. In my testing, this is not true. On modern hardware built-in MSAA seems to be extremely cheap even on low-power mobile devices, while the post-processing FXAA or SMAA passes cause a considerable frame rate drop on every scene I’ve tested them with, and are also lower quality than MSAA.

## Lights

Direct lights (SpotLight, PointLight, RectAreaLight, and DirectionalLight) are slow. Use as few direct lights as possible in your scenes.
Avoid adding and removing lights from your scene since this requires the WebGLRenderer to recompile all shader programs (it does cache the programs so subsequent times that you do this it will be faster than the first). Instead, use light.visible = false or light.intensiy = 0.
Turn on renderer.physicallyCorrectLights for accurate lighting that uses SI units.

## Shadows

If your scene is static, only update the shadow map when something changes, rather than every frame.
Use a CameraHelper to visualize the shadow camera’s viewing frustum.
Make the shadow frustum as small as possible.
Make the shadow texture as low resolution as possible.
Remember that point light shadows are more expensive than other shadow types since they must render six times (once in each direction), compared with a single time for DirectionalLight and SpotLight shadows.
While we’re on the topic of PointLight shadows, note that the CameraHelper only visualizes one out of six of the shadow directions when used to visualize point light shadows. It’s still useful, but you’ll need to use your imagination for the other five directions.

## Materials

MeshLambertMaterial doesn’t work for shiny materials, but for matte materials like cloth it will give very similar results to MeshPhongMaterial but is faster.
If you are using morph targets, make sure you set morphTargets = true in your material, or they won’t work!
Same goes for morph normals.
And if you’re using a SkinnedMesh for skeletal animations, make sure that material.skinning = true.
Materials used with morph targets, morph normals, or skinning can’t be shared. You’ll need to create a unique material for each skinned or morphed mesh ( material.clone() is your friend here).
Custom Materials#
Only update your uniforms when they change, not every frame.

## Geometry

Avoid using LineLoop since it must be emulated by line strip.

## Textures

All of your textures need to be power of two (POT) size: 1,2,4,8,16,…,512,2048,….
Don’t change the dimensions of your textures. Create new ones instead, it’s faster
Use the smallest texture sizes possible (can you get away with a 256x256 tiled texture? You might be surprised!).
Non-power-of-two (NPOT) textures require linear or nearest filtering, and clamp-to-border or clamp-to-edge wrapping. Mipmap filtering and repeat wrapping are not supported. But seriously, just don’t use NPOT textures.
All textures with the same dimensions are the same size in memory, so JPG may have a smaller file size than PNG, but it will take up the same amount of memory on your GPU.

## Antialiasing

The worst-case scenario for antialiasing is geometry made up of lots of thin straight pieces aligned parallel with one another. Think metal window blinds or a lattice fence. If it’s at all possible, don’t include geometry like this in your scenes. If you have no choice, consider replacing the lattice with a texture instead, as that may give better results.

## Post-Processing

The built-in antialiasing doesn’t work with post-processing (at least in WebGL 1). You will need to do this manually, using FXAA or SMAA (probably faster, better)
Since you are not using the built-in AA, be sure to disable it!
three.js has loads of post-processing shaders, and that’s just great! But remember that each pass requires rendering your entire scene. Once you’re done testing, consider whether you can combine your passes into one single custom pass. It’s a little more work to do this, but can come with a considerable performance increase.
Disposing of Things#
Removing something from your scene?

First of all, consider not doing that, especially if you will add it back again later. You can hide objects temporarily using object.visible = false (works for lights too), or material.opacity = 0. You can set light.intensity = 0 to disable a light without causing shaders to recompile.

## Performance

Set object.matrixAutoUpdate = false for static or rarely moving objects and manually call object.updateMatrix() whenever their position/rotation/quaternion/scale are updated.
Transparent objects are slow. Use as few transparent objects as possible in your scenes.
use alphatest instead of standard transparency if possible, it’s faster.
When testing the performance of your apps, one of the first things you’ll need to do is check whether it is CPU bound, or GPU bound. Replace all materials with basic material using scene.overrideMaterial (see beginners tips and the start of the page). If performance increases, then your app is GPU bound. If performance doesn’t increase, your app is CPU bound.
When performance testing on a fast machine, you’ll probably be getting the maximum frame rate of 60FPS. Run chrome using open -a "Google Chrome" --args --disable-gpu-vsync for an unlimited frame rate.
Modern mobile devices have high pixel ratios as high as 5 - consider limiting the max pixel ratio to 2 or 3 on these devices. At the expense of some very slight blurring of your scene you will gain a considerable performance increase.
Bake lighting and shadow maps to reduce the number of lights in your scene.
Keep an eye on the number of drawcalls in your scene. A good rule of thumb is fewer draw calls = better performance.
Far away objects don’t need the same level of detail as objects close to the camera. There are many tricks used to increase performance by reducing the quality of distant objects. Consider using a LOD (Level Of Detail) object. You may also get away with only updating position / animation every 2nd or 3rd frame for distant objects, or replacing them with a billboard - that is, a drawing of the object.

## Advanced Tips

Don’t use TriangleFanDrawMode, it’s slow.
Use geometry instancing when you have hundreds or thousands of similar geometries.
Animate on the GPU instead of the CPU, especially when animating vertices or particles (see THREE.Bas for one approach to doing this).

# For React Three Fiber

## Performance pitfalls

## Tips and Tricks

The most important gotcha in three.js is that creating objects can be expensive, think twice before you mount/unmount things! Every material or light that you put into the scene has to compile, every geometry you create will be processed. Share materials and geometries if you can, either in global scope or locally:

```js
const geom = useMemo(() => new BoxGeometry(), [])
const mat = useMemo(() => new MeshBasicMaterial(), [])
return items.map(i => <mesh geometry={geom} material={mat} ...
```

Try to use instancing as much as you can when you need to display many objects of a similar type!

Avoid setState in loops
TLDR, don't, mutate inside useFrame!

Threejs has a render-loop, it does not work like the DOM does. Fast updates are carried out in useFrame by mutation. useFrame is your per-component render-loop.

It is not enough to set values in succession, you need frame deltas. Instead of position.x += 0.1 consider position.x += delta or your project will run at different speeds depending on the end-users system. Many updates in threejs need to be paired with update flags (.needsUpdate = true), or imperative functions (.updateProjectionMatrix()).

You might be tempted to setState inside useFrame but there is no reason to. You would only complicate something as simple as an update by routing it through React's scheduler, triggering component render etc.

❌ setState in loops is bad

```js
useEffect(() => {
  const interval = setInterval(() => setX((x) => x + 0.1), 1);
  return () => clearInterval(interval);
}, []);
```

❌ setState in useFrame is bad

```js
const [x, setX] = useState(0);
useFrame(() => setX((x) => x + 0.1));
return <mesh position-x={x} />;
```

❌ setState in fast events is bad

```js
<mesh onPointerMove={(e) => setX((x) => e.point.x)} />
```

✅ Instead, just mutate, use deltas
In general you should prefer useFrame. Consider mutating props safe as long as the component is the only entity that mutates. Use deltas instead of fixed values so that your app is refresh-rate independent and runs at the same speed everywhere!

```js
const meshRef = useRef();
useFrame((state, delta) => (meshRef.current.position.x += delta));
return <mesh ref={meshRef} />;
```

Same goes for events, use references.

```js
<mesh onPointerMove={(e) => (ref.current.position.x = e.point.x)} />
```

If you must use intervals, use references as well, but keep in mind that this is not refresh-rate independent.

```js
useEffect(() => {
  const interval = setInterval(() => (ref.current.position.x += 0.1), 1);
  return () => clearInterval(interval);
}, []);
```

Handle animations in loops
The frame loop is where you should place your animations. For instance using lerp, or damp.

✅ Use lerp + useFrame

```js
function Signal({ active }) {
const meshRef = useRef()
useFrame((state, delta) => {
meshRef.current.position.x = THREE.MathUtils.lerp(meshRef.current.position.x, active ? 100 : 0, 0.1)
})
return <mesh ref={meshRef} />
```

✅ Or react-spring
Or, use animation libraries. React-spring has its own frame-loop and animates outside of React. Framer-motion is another popular alternative.

```js
import { a, useSpring } from '@react-spring/three'

function Signal({ active }) {
const { x } = useSpring({ x: active ? 100 : 0 })
return <a.mesh position-x={x} />
```

Do not bind to fast state reactively
Using state-managers and selective state is fine, but not for updates that happen rapidly for the same reason as above.

❌ Don't bind reactive fast-state

```js
import { useSelector } from "react-redux";
```

// Assuming that x gets animated inside the store 60fps

```js
const x = useSelector((state) => state.x);
return <mesh position-x={x} />;
```

✅ Fetch state directly
For instance using Zustand (same in Redux et al).

```js
useFrame(() => (ref.current.position.x = api.getState().x));
return <mesh ref={ref} />;
```

Don't mount indiscriminately
In threejs it is very common to not re-mount at all, see the "disposing of things" section in discover-three. This is because buffers and materials get re-initialized/compiled, which can be expensive.

❌ Avoid mounting runtime

```js
{
  stage === 1 && <Stage1 />;
}
{
  stage === 2 && <Stage2 />;
}
{
  stage === 3 && <Stage3 />;
}
```

✅ Consider using visibility instead

```js
<Stage1 visible={stage === 1} />
<Stage2 visible={stage === 2} />
<Stage3 visible={stage === 3} />

function Stage1(props) {
return (
<group {...props}>
...
```

✅ Use startTransition for expensive ops
React 18 introduces the startTransition and useTransition APIs to defer and schedule work and state updates. Use these to de-prioritize expensive operations.

Since version 8 of Fiber canvases use concurrent mode by default, which means React will schedule and defer expensive operations. You don't need to do anything, but you can play around with the experimental scheduler and see if marking ops with a lesser priority makes a difference.

```js
import { useTransition } from 'react'
import { Points } from '@react-three/drei'

const [isPending, startTransition] = useTransition()
const [radius, setRadius] = useState(1)
const positions = calculatePositions(radius)
const colors = calculateColors(radius)
const sizes = calculateSizes(radius)

<Points
positions={positions}
colors={colors}
sizes={sizes}
onPointerOut={() => {
startTransition(() => {
setRadius(prev => prev + 1)
})
}}

>   <meshBasicMaterial vertexColors />
> </Points>
```

Don't re-create objects in loops
Try to avoid creating too much effort for the garbage collector, re-pool objects when you can!

❌ Bad news for the GC
This creates a new vector 60 times a second, which allocates memory and forces the GC to eventually kick in.

```js
useFrame(() => {
  ref.current.position.lerp(new THREE.Vector3(x, y, z), 0.1);
});
```

✅ Better re-use object
Set up re-used objects in global or local space, now the GC will be silent.

```js
function Foo(props)
const vec = new THREE.Vector()
useFrame(() => {
ref.current.position.lerp(vec.set(x, y, z), 0.1)
})
```

useLoader instead of plain loaders
Threejs loaders give you the ability to load async assets (models, textures, etc), but if you do not re-use assets it can quickly become problematic.

❌ No re-use is bad for perf
This re-fetches, re-parses for every component instance.

```js
function Component() {
  const [texture, set] = useState();
  useEffect(() => void new TextureLoader().load(url, set), []);
  return texture ? (
    <mesh>
      <sphereGeometry />
      <meshBasicMaterial map={texture} />
    </mesh>
  ) : null;
}
```

Instead use useLoader, which caches assets and makes them available throughout the scene.

✅ Cache and re-use objects

```js
function Component() {
  const texture = useLoader(TextureLoader, url);
  return (
    <mesh>
      <sphereGeometry />
      <meshBasicMaterial map={texture} />
    </mesh>
  );
}
```

Regarding GLTF's try to use GLTFJSX as much as you can, this will create immutable JSX graphs which allow you to even re-use full models.
